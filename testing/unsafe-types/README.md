# Unsafe type operations in Go

## Known unsafe operations
1. [`interface` assignment "write" race condition](unsafeinterface/README.md)
2. [TBD: `slice` read overflow race condition](#)
3. [`slice` write overflow race condition](unsafeslice/README.md)
4. [`string` read overflow race condition](unsafestring/README.md)
5. [TBD: `map` read overflow race condition](#)
6. [TBD: `map` write overflow race condition](#)
7. [TBD: type assertion read race condition](#)

## General considerations
The Go language makes many assumptions about how a Go program should be compiled by default. Optimization, executable debugging, and executable protections are areas where such assumptions may not be obvious concerns until further inspection.

### Impact of optimizations
During compilation, the Go compiler will attempt to optimize the produced executable through inlining certain operations, or statically computing a deterministic result (e.g. `c = a; c = b;`, `c` will always result in a value `b`). While typically this will not impede a normal program's execution since it's merely an IR transform, this could lead to a race condition being optimized out. Furthermore, this could result in a target function we may want to execute being inlined if it is cheap enough to inline.

In order to identify whether the compiler actually performs such an optimization, `-gcflags='all=-m=1'` can be used to review the chosen optimizations for the target. This also allows us to identify which variables are allocated to the heap, and which remain on the stack.

```
# <snip>/testing/unsafe-types/unsafeinterface
./main.go:30:13: inlining call to fmt.Println
./main.go:49:6: can inline StructIntPtr.Exec
./main.go:57:6: can inline StructFuncPtr.Exec
./main.go:66:19: inlining call to runtime.NumCPU
./main.go:67:14: inlining call to fmt.Println
./main.go:103:16: inlining call to fmt.Println
./main.go:19:14: leaking param: i
./main.go:20:44: ... argument does not escape
./main.go:30:14: "win" escapes to heap
./main.go:30:14: i escapes to heap
./main.go:30:14: j escapes to heap
./main.go:30:13: []interface {} literal does not escape
./main.go:49:7: s does not escape
./main.go:57:7: u does not escape
./main.go:72:2: moved to heap: winAddr
./main.go:79:6: moved to heap: confused
./main.go:67:15: "need >= 2 CPUs" escapes to heap
./main.go:67:14: []interface {} literal does not escape
./main.go:80:6: &StructIntPtr literal escapes to heap
./main.go:81:6: &StructFuncPtr literal escapes to heap
./main.go:89:5: func literal escapes to heap
./main.go:99:4: func literal does not escape
./main.go:103:16: []interface {} literal does not escape
<autogenerated>:1: leaking param: .this
<autogenerated>:1: inlining call to StructIntPtr.Exec
<autogenerated>:1: .this does not escape
<autogenerated>:1: inlining call to StructFuncPtr.Exec
<autogenerated>:1: .this does not escape
<autogenerated>:1: .this does not escape
```

While this is useful, in larger programs this can be difficult to properly search. However, it is possible to output similar values through the `-json=0,file://./some/directory` option within `-gcflags`. It is notable however, `./some/directory` will be produced for each package built during compilation, relative to that package's location on disk. A source-built version of Go is recommended for this option, as you can symlink to a version-controlled copy of the source so the produced files can easily be removed after analysis. The output of our unsafe interface program has been included below, where we can see our inlined function starting on line 99 fails to be inlined due to function high function complexity. As a result, our race is possible.

```json
{"range":{"start":{"line":19,"character":6},"end":{"line":19,"character":6}},"severity":3,"code":"cannotInlineFunction","source":"go compiler","message":"function too complex: cost 139 exceeds budget 80"}
{"range":{"start":{"line":29,"character":6},"end":{"line":29,"character":6}},"severity":3,"code":"cannotInlineFunction","source":"go compiler","message":"function too complex: cost 140 exceeds budget 80"}
...
{"range":{"start":{"line":49,"character":6},"end":{"line":49,"character":6}},"severity":3,"code":"canInlineFunction","source":"go compiler","message":"cost: 0"}
{"range":{"start":{"line":57,"character":6},"end":{"line":57,"character":6}},"severity":3,"code":"canInlineFunction","source":"go compiler","message":"cost: 65"}
{"range":{"start":{"line":64,"character":6},"end":{"line":64,"character":6}},"severity":3,"code":"cannotInlineFunction","source":"go compiler","message":"unhandled op GO"}
...
{"range":{"start":{"line":89,"character":5},"end":{"line":89,"character":5}},"severity":3,"code":"cannotInlineFunction","source":"go compiler","message":"unhandled op FOR"}
...
{"range":{"start":{"line":99,"character":4},"end":{"line":99,"character":4}},"severity":3,"code":"cannotInlineFunction","source":"go compiler","message":"function too complex: cost 81 exceeds budget 80"}
```

### Searching for execution targets
Several features of binaries produced by `go build` with default settings allow us to do some questionable things:

* PIE/NX/etc is either disabled by default or not supported.
* Go uses deterministic heap addressing.
* Go includes debugging information by default.

With this in mind, if we have access to a Go binary, we can start by identifying the available functions using utilities such as `nm`. This will give us a lay of the land for what we have available to execute, and the address we can refer to them by.

```
$ nm -a unsafeinterface | grep win
000000000105cde0 t __rt0_amd64_darwin
000000000109fcc0 t _main.win
00000000010ecbe0 s _main.win.stkobj
00000000010937b0 t _os.useSyscallwdDarwin
0000000001182190 b _syscall.execveDarwin
```

When choosing a function to target, it is extremely important to consider the number of arguments and their required types. At the point in which your target function is executed, the stack will be prepared with values intended for the original function. In some cases, this can minimize your attack surface (e.g. if no arguments are provided and no useful functions accept 0 arguments), or in other cases it could expand them (e.g. if one argument is provided, and an ideal function requires one argument).

### Settings which can cause "problems"
Go's build system can be configured to use PIE, which will make it less trivial for us to identify the address of our target function. This can be enabled through `-buildmode=pie`. However, this carries the same implications as enabling PIE for any other binary performance-wise. Furthermore, providing `-ldflags='-s -w'` will also omit DWARF information & debug symbols.